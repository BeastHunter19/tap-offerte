input {
  tcp {
    port => 5044
    codec => json
  }
}

filter {
  # Check if PDF exists in Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "flyers"
    query => "_id:%{[checksum]}"
    result_size => 1
    enable_sort => false
    retry_on_failure => 5
    docinfo_fields => {
      "_id" => "[@metadata][flyer_id]"
    }
    fields => {
      "source" => "[@metadata][flyer_source]"
    }
  }
  # The following script checks if the source location already exists in the flyer source.
  # If it does not exist it flags the event for further processing, otherwise the event is a duplicate.
  ruby {
    code => '
      require "json"

      place = event.get("[source]") || {}
      place_id = place["placeId"]
      entry = nil

      if place_id
        entry = {"placeId" => place_id}
        loc = place["location"]
        if loc.is_a?(Hash)
          lat = loc["lat"]
          lon = loc["lon"]
          if !lat.nil? && !lon.nil?
            entry["location"] = {"lat" => lat.to_f, "lon" => lon.to_f}
          end
        end
      end

      flyer_source = event.get("[@metadata][flyer_source]")
      place_exists = false
      if flyer_source && place_id
        list = flyer_source.is_a?(Array) ? flyer_source : [flyer_source]
        list.each do |item|
          next unless item.is_a?(Hash)
          if item["placeId"] == place_id
            place_exists = true
            break
          end
        end
      end

      event.set("[@metadata][flyer_has_place]", place_exists)
      event.set("[@metadata][new_source_entry]", entry)

      flyer_id = event.get("[@metadata][flyer_id]")
      if flyer_id && entry && !place_exists
        script_source = %q{
if (ctx._source.source == null) {
  ctx._source.source = new ArrayList();
} else if (!(ctx._source.source instanceof List)) {
  ctx._source.source = new ArrayList(Collections.singletonList(ctx._source.source));
}
boolean exists = false;
for (item in ctx._source.source) {
  if (item == null) { continue; }
  Object pid = item.containsKey("placeId") ? item.get("placeId") : null;
  if (pid != null && pid.equals(params.placeId)) {
    exists = true;
    break;
  }
}
if (!exists) {
  Map newEntry = new HashMap();
  newEntry.put("placeId", params.placeId);
  if (params.location != null) {
    newEntry.put("location", params.location);
  }
  ctx._source.source.add(newEntry);
}
        }.strip

        body = {
          "query" => { "term" => { "flyer_checksum" => flyer_id } },
          "script" => {
            "lang" => "painless",
            "source" => script_source,
            "params" => {
              "placeId" => entry["placeId"],
              "location" => entry["location"]
            }
          }
        }

        event.set("[@metadata][offers_update_body]", body.to_json)
      end
    '
  }
}

output {
  stdout {
    codec => rubydebug { metadata => true }
  }
  # Send message to kafka only if the PDF is not a duplicate
  if [@metadata][total_hits] == 0 {
    kafka {
      bootstrap_servers => "broker:9092"
      topic_id => "pdf-metadata"
      codec => json
    }
  # Add the new source to the existing flyer if the place is not already present
  } else if ![@metadata][flyer_has_place] {
    # This output updates the flyer document
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "flyers"
      action => "update"
      document_id => "%{[@metadata][flyer_id]}"
      retry_on_conflict => 5
      script_lang => "painless"
      script_var_name => "event"
      script => '
Map incoming = params.event != null ? (Map) params.event.get("source") : null;
if (incoming == null) { return; }
Object placeIdObj = incoming.get("placeId");
if (placeIdObj == null) { return; }
String placeId = placeIdObj.toString();
Map location = null;
Object locObj = incoming.get("location");
if (locObj instanceof Map) {
  Map locMap = (Map) locObj;
  Object latObj = locMap.get("lat");
  Object lonObj = locMap.get("lon");
  if (latObj != null && lonObj != null) {
    location = new HashMap();
    location.put("lat", Double.parseDouble(latObj.toString()));
    location.put("lon", Double.parseDouble(lonObj.toString()));
  }
}
if (ctx._source.source == null) {
  ctx._source.source = new ArrayList();
} else if (!(ctx._source.source instanceof List)) {
  ctx._source.source = new ArrayList(Collections.singletonList(ctx._source.source));
}
boolean exists = false;
for (item in ctx._source.source) {
  if (item == null) { continue; }
  Object pid = item.containsKey("placeId") ? item.get("placeId") : null;
  if (pid != null && pid.equals(placeId)) {
    exists = true;
    break;
  }
}
if (!exists) {
  Map newEntry = new HashMap();
  newEntry.put("placeId", placeId);
  if (location != null) {
    newEntry.put("location", location);
  }
  ctx._source.source.add(newEntry);
}
      '
    }
    # This output performs an update_by_query to ensure consistency in the offers index
    if [@metadata][offers_update_body] {
      http {
        url => "http://elasticsearch:9200/offers/_update_by_query?conflicts=proceed"
        http_method => "post"
        content_type => "application/json"
        format => "message"
        message => "%{[@metadata][offers_update_body]}"
      }
    }
  }
}